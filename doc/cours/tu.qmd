---
title: "Les tests unitaires"
description: "Introduction aux TU avec pytest"
author: "Ludovic Deneuville"
format:
  html:
    toc: true
    toc-location: left
    toc-expand: 3
from: markdown+emoji
number-sections: true
number-depth: 3
---


Les **tests unitaires (TU)** sont des tests automatisés qui vérifient le comportement d'une petite unité de code, de manière isolée. Leur objectif est de s'assurer que chaque composant du programme fonctionne comme prévu.

## La fonction à tester

Commençons par écrire la fonction à tester.

Prenons l'exemple d'une fonction qui prend en paramètre un entier et retourne s'il est impair.

```{.python filename="est_impair.py"}
def est_impair(n) -> bool:
    if not isinstance(n, int):
        raise TypeError("Le paramètre doit être un entier.")
    return n % 2 != 0
```

Il ne manque pas quelque chose ???

Mais oui bien sûr la doc ! Profitons-en pour écrire des doctests (bloc *Examples*)

## La doc

```{.python filename="est_impair.py"}
def est_impair(n) -> bool:
    """
    Détermine si un nombre est impair. 

    Parameters
    ----------
    n : int
        Un entier à vérifier.

    Returns
    -------
    bool
        True si `n` est impair, False sinon.
        Raises TypeError si n n'est pas un entier.

    Examples
    --------
    >>> est_impair(5)
    True
    >>> est_impair(4)
    False
    """
    if not isinstance(n, int):
        raise TypeError("Le paramètre doit être un entier.")
    return n % 2 != 0
```

Les doctests c'est pas mal mais il y a des outils beaucoup plus puissants pour réaliser des tests unitaires en Python, par exemple *pytest*. Une alternative est d'utiliser *unittest*.


## La méthode naïve

::: {.callout-note}
Ce que l'on fait tous naturellement !

Nous appelons la fonction et affichons le résultat pour vérifier.
:::

```{.python}
print(est_impair(1))

print(est_impair(2))

est_impair("toto")
```

::: {.callout-tip title="Pourquoi ce n'est pas la bonne méthode"}
- Pas automatisé : Nécessite une intervention manuelle pour vérifier les résultats
- Non reproductible : Chaque test doit être relancé à la main
- Temps perdu : Refaire les tests manuellement est chronophage
- Oublis possibles : Facile de négliger des cas limites ou des scénarios d'erreur
:::


## Un premier test unitaire avec pytest

Testons par exemple un cas nominal : vérifions que `est_impair(3)` retourne *True*.

Créons dans le même dossier, un fichier `test_est_impair.py`. 

Nous importons le fichier contenant la méthode à tester *est_impair.py*.

*from est_impair import est_impair* signifie : depuis (from) le *fichier est_impair.py* importons la fonction *est_impair()*

```{.python filename="test_est_impair.py"}
from est_impair import est_impair

def test_nombre_impair():
    # GIVEN
    nombre = 3

    # WHEN
    resultat = est_impair(nombre)

    # THEN
    assert resultat is True
```

Un test unitaire se déroule en 3 étapes :

- *GIVEN* : nous donnons les paramètres à tester
- *WHEN* : nous appelons la fonction
- *THEN* : nous vérifions que le résultat attendu est le même que celui obtenu

De la même manière, il faut créer [un test unitaire pour chacun des retours possibles]{.underline} :

- *True*
- *False*
- *Exception TypeError*

```{.python filename="test_est_impair.py"}
import pytest
from est_impair import est_impair

def test_nombre_impair():
    # GIVEN
    nombre = 3

    # WHEN
    resultat = est_impair(nombre)

    # THEN
    assert resultat is True

def test_nombre_pair():
    # GIVEN
    nombre = 2

    # WHEN
    resultat = est_impair(nombre)

    # THEN
    assert resultat is False

def test_type_erreur_string():
    # GIVEN
    valeur = "5"

    # WHEN/THEN
    with pytest.raises(TypeError, match="Le paramètre doit être un entier."):
        est_impair(valeur)
```

::: {.callout-caution title="Remarques"}
- Pour tester qu'une exception est levée, la syntaxe est légérement différente
- Nous avons besoin d'importer le package *pytest*
:::

## Lancer les TU

Il y a plusieurs possibilités pour lancer les tests unitaires :

- en ligne de commande
  - `pytest`
  - `pytest -v` :arrow_right: v : verbose, pour avoir plus de détails
  - `pytest --tb=short` pour afficher une trace courte et résumée (utile pour débugguer)
  - `pytest --maxfail=1` pour s'arrêter dès le premier échec
  - `python -m pytest` si *pytest* n'a pas été ajouté au *PATH*
  - `python -m pytest --doctest-modules`, pour inclure les doctests
- Via l'interface de VSCode avec l'icone en forme de fiole à gauche


## TU avancés avec pytest.mark.parametrize

*pytest.mark.parametrize* est une fonctionnalité de pytest qui permet d'exécuter un même test plusieurs fois avec différents ensembles de données d'entrée. 

Cela remplace la section *GIVEN* et permet d'éviter la duplication de code pour des cas de test similaires.

```{.python filename="test_est_impair.py"}
import pytest
from est_impair import est_impair

@pytest.mark.parametrize(
    "nombre, resultat_attendu",
    [
        (3, True),
        (2, False),
    ],
)
def test_est_impair_valeurs_valides(nombre, resultat_attendu):
    # WHEN
    resultat_obtenu = est_impair(nombre) 

    # THEN
    assert resultat_obtenu == resultat_attendu

@pytest.mark.parametrize(
    "valeur_invalide, type_exception, message",
    [
        ("5", TypeError, "Le paramètre doit être un entier."),
        (3.5, TypeError, "Le paramètre doit être un entier."),
    ],
)
def test_est_impair_valeurs_invalides(valeur_invalide, type_exception, message):
    # WHEN / THEN
    with pytest.raises(type_exception, match=message):
        est_impair(valeur_invalide)
```

Pour comprendre le code ci-dessus, imaginez que pour chaque élément du tableau ci-dessous, vous allez tester `assert est_impair(nombre) == resultat_attendu`

| **Nombre** | **Résultat attendu** |
|------------|----------------------|
| 3          | True                 |
| 2          | False                |

Et de même pour chacune des exceptions :

```{.python}
    with pytest.raises(type_exception, match=message):
        est_impair(valeur_invalide)
```

| **Valeur invalide** | **Type d'exception** | **Message**                          |
|---------------------|----------------------|--------------------------------------|
| "5"                 | `TypeError`         | Le paramètre doit être un entier.    |
| 3.5                 | `TypeError`         | Le paramètre doit être un entier.    |


## Couverture de test

La **couverture de tests** (ou *test coverage*) est une mesure qui évalue dans quelle proportion le code d'un programme est exécuté pendant l'exécution des tests. Elle permet de vérifier si les tests couvrent toutes les parties critiques du code. 

Une couverture élevée (proche de 100 %) est généralement un indicateur positif, mais elle ne garantit pas que les tests sont de bonne qualité. 

Il est essentiel de combiner une couverture élevée avec des tests pertinents pour détecter les bugs.

Générer la couverture de tests avec *pytest-cov* (possible également avec le package *coverage*).

```{.bash}
# Installer les packages necessaires
pip install pytest pytest-cov

# Générer un rapport de couverture
pytest --cov

# Générer un rapport html (plus complet)
pytest --cov --cov-report=html
```

## Exercice {.unnumbered}

Imaginons que vous souhaitez faire évoluer votre fonction *est_impair()*, maintenant elle doit accepter les nombres flottants dont la partie décimale est nulle.

Par exemple :

- `est_impair(2.0)` :arrow_right: True
- `est_impair(3.0)` :arrow_right: False
- `est_impair(4.5)` léve toujours une exception TypeError

---

- [ ] Modifiez la fonction *est_impair()*
- [ ] Vérifiez la couverture de test (elle ne doit plus être à 100 %)
- [ ] Écrivez le nouveau test unitaire
- [ ] Vérifiez que la couverture de test est repassée à 100 %


## Liens {.unnumbered}

- [Python, the right way : Tester son code et le TDD](https://datacrafting.substack.com/p/jour-24-ii-python-the-right-way-tester){target="_blank"}
- [Python, the right way : Pytest](https://datacrafting.substack.com/p/jour-25-ii-python-the-right-way-pytest){target="_blank"}